# -*- coding: utf-8 -*-
"""Analysis of Greedy Algorithms.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iNO-EOSXnH1JnKUBH184sZQQNifUJqeT
"""

# ============================================================================
# IMPROVED ALGORITHM FOR VERTEX COVER IN UNIT DISK GRAPHS - COLAB VERSION
# ============================================================================

# Install required libraries
!pip install -q networkx scipy matplotlib numpy

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from scipy.spatial.distance import pdist, squareform
import time
import warnings
import csv
import os
warnings.filterwarnings('ignore')

print("‚úÖ Libraries loaded")

# ============================================================================
# 1. DIFFERENT GREEDY STRATEGIES FOR COMPARISON
# ============================================================================

def generate_udg(n, R, seed=None):
    """Generate random Unit Disk Graph"""
    if seed:
        np.random.seed(seed)

    points = np.random.rand(n, 2)
    G = nx.Graph()

    for i in range(n):
        G.add_node(i, pos=points[i])

    dist_matrix = squareform(pdist(points))

    for i in range(n):
        for j in range(i+1, n):
            if dist_matrix[i, j] <= R:
                G.add_edge(i, j)

    return G, points

def maximal_matching(G):
    """Maximal matching (for 2-approximation baseline)"""
    matching = set()
    matched = set()

    edges = list(G.edges())
    np.random.shuffle(edges)  # Random order

    for u, v in edges:
        if u not in matched and v not in matched:
            matching.add((min(u, v), max(u, v)))
            matched.add(u)
            matched.add(v)

    return matching

# -------------------------------------------------------------------
# ALGORITHM 1: ORIGINAL DEGREE-BASED GREEDY
# -------------------------------------------------------------------
def greedy_degree_based(G):
    """Original greedy: select vertex with maximum degree"""
    cover = set()
    H = G.copy()

    while H.number_of_edges() > 0:
        degrees = dict(H.degree())
        v = max(degrees, key=degrees.get)
        cover.add(v)
        H.remove_node(v)

    return cover

# -------------------------------------------------------------------
# ALGORITHM 2: IMPROVED GREEDY (Edge-count based)
# -------------------------------------------------------------------
def greedy_edge_based(G):
    """
    Improved greedy: select vertex covering most uncovered edges
    Better for UDGs
    """
    cover = set()
    uncovered_edges = set(G.edges())

    while uncovered_edges:
        # Score = number of uncovered edges incident to vertex
        scores = {}
        for v in G.nodes():
            if v not in cover:
                count = 0
                for u in G.neighbors(v):
                    if u not in cover:
                        edge = (min(u, v), max(u, v))
                        if edge in uncovered_edges:
                            count += 1
                scores[v] = count

        if not scores:
            break

        v = max(scores, key=scores.get)
        cover.add(v)

        # Remove covered edges
        edges_to_remove = []
        for u in G.neighbors(v):
            edge = (min(u, v), max(u, v))
            if edge in uncovered_edges:
                edges_to_remove.append(edge)

        for edge in edges_to_remove:
            uncovered_edges.remove(edge)

    return cover

# -------------------------------------------------------------------
# ALGORITHM 3: 2-APPROXIMATION VIA MAXIMAL MATCHING (BEST FOR PAPER)
# -------------------------------------------------------------------
def greedy_matching_based(G):
    """
    2-approximation guarantee: maximal matching
    Theoretical guarantee: |C| ‚â§ 2|M| ‚â§ 2|OPT|
    """
    matching = maximal_matching(G)
    cover = set()

    for u, v in matching:
        cover.add(u)
        cover.add(v)

    return cover, matching

# ============================================================================
# 2. COMPARATIVE EXPERIMENTS
# ============================================================================

print("\nüî¨ COMPARATIVE ANALYSIS OF GREEDY STRATEGIES")
print("="*60)

np.random.seed(42)
n_values = [100, 200, 300, 400, 500]
R_values = [0.15, 0.20, 0.25]

results_comparison = []

for R in R_values:
    print(f"\nRadius R = {R}:")
    print("-" * 50)

    for n in n_values:
        G, _ = generate_udg(n, R, seed=n)

        # Run all three algorithms
        start = time.perf_counter()
        cover1 = greedy_degree_based(G)
        time1 = (time.perf_counter() - start) * 1000

        start = time.perf_counter()
        cover2 = greedy_edge_based(G)
        time2 = (time.perf_counter() - start) * 1000

        start = time.perf_counter()
        cover3, matching = greedy_matching_based(G)
        time3 = (time.perf_counter() - start) * 1000

        matching_size = len(matching)
        ratio1 = len(cover1) / matching_size if matching_size > 0 else 0
        ratio2 = len(cover2) / matching_size if matching_size > 0 else 0
        ratio3 = len(cover3) / matching_size if matching_size > 0 else 0

        results_comparison.append({
            'n': n, 'R': R,
            'degree_cover': len(cover1), 'degree_time': time1, 'degree_ratio': ratio1,
            'edge_cover': len(cover2), 'edge_time': time2, 'edge_ratio': ratio2,
            'match_cover': len(cover3), 'match_time': time3, 'match_ratio': ratio3,
            'matching': matching_size
        })

        print(f"n={n:3d}: Degree[{len(cover1):4.0f},{ratio1:.3f}] | "
              f"Edge[{len(cover2):4.0f},{ratio2:.3f}] | "
              f"Match[{len(cover3):4.0f},{ratio3:.3f}]")

# ============================================================================
# 3. VISUALIZATION 1: MAIN COMPARISON PLOT
# ============================================================================

print("\nüìä GENERATING MAIN COMPARISON VISUALIZATION...")

fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# Plot 1: Approximation ratio comparison
ax1 = axes[0, 0]
n_vals = sorted(list(set([r['n'] for r in results_comparison if r['R'] == 0.2])))

ratios_degree = [np.mean([r['degree_ratio'] for r in results_comparison
                         if r['n'] == n and r['R'] == 0.2]) for n in n_vals]
ratios_edge = [np.mean([r['edge_ratio'] for r in results_comparison
                       if r['n'] == n and r['R'] == 0.2]) for n in n_vals]
ratios_match = [np.mean([r['match_ratio'] for r in results_comparison
                        if r['n'] == n and r['R'] == 0.2]) for n in n_vals]

ax1.plot(n_vals, ratios_degree, 'r-o', linewidth=2, markersize=8,
        label='Degree-based (original)')
ax1.plot(n_vals, ratios_edge, 'b-s', linewidth=2, markersize=8,
        label='Edge-based (improved)')
ax1.plot(n_vals, ratios_match, 'g-^', linewidth=2, markersize=8,
        label='Matching-based (2-approx)')
ax1.axhline(y=2.0, color='k', linestyle='--', alpha=0.5, label='Theoretical bound')

ax1.set_xlabel('Number of vertices (n)', fontweight='bold')
ax1.set_ylabel('Approximation ratio |C|/|M|', fontweight='bold')
ax1.set_title('(a) Algorithm Comparison: Approximation Quality', fontweight='bold')
ax1.legend(loc='upper left')
ax1.grid(True, alpha=0.3)
ax1.set_ylim(1.0, 2.2)

# Plot 2: Running time comparison
ax2 = axes[0, 1]
times_degree = [np.mean([r['degree_time'] for r in results_comparison
                        if r['n'] == n and r['R'] == 0.2]) for n in n_vals]
times_edge = [np.mean([r['edge_time'] for r in results_comparison
                      if r['n'] == n and r['R'] == 0.2]) for n in n_vals]
times_match = [np.mean([r['match_time'] for r in results_comparison
                       if r['n'] == n and r['R'] == 0.2]) for n in n_vals]

ax2.plot(n_vals, times_degree, 'r-o', linewidth=2, markersize=8, label='Degree-based')
ax2.plot(n_vals, times_edge, 'b-s', linewidth=2, markersize=8, label='Edge-based')
ax2.plot(n_vals, times_match, 'g-^', linewidth=2, markersize=8, label='Matching-based')

ax2.set_xlabel('Number of vertices (n)', fontweight='bold')
ax2.set_ylabel('Running time (ms)', fontweight='bold')
ax2.set_title('(b) Algorithm Comparison: Running Time', fontweight='bold')
ax2.legend(loc='upper left')
ax2.grid(True, alpha=0.3)

# Plot 3: Cover size growth
ax3 = axes[1, 0]
covers_degree = [np.mean([r['degree_cover'] for r in results_comparison
                         if r['n'] == n and r['R'] == 0.2]) for n in n_vals]
covers_edge = [np.mean([r['edge_cover'] for r in results_comparison
                       if r['n'] == n and r['R'] == 0.2]) for n in n_vals]
covers_match = [np.mean([r['match_cover'] for r in results_comparison
                        if r['n'] == n and r['R'] == 0.2]) for n in n_vals]

ax3.plot(n_vals, covers_degree, 'r-o', linewidth=2, markersize=8, label='Degree-based')
ax3.plot(n_vals, covers_edge, 'b-s', linewidth=2, markersize=8, label='Edge-based')
ax3.plot(n_vals, covers_match, 'g-^', linewidth=2, markersize=8, label='Matching-based')

ax3.set_xlabel('Number of vertices (n)', fontweight='bold')
ax3.set_ylabel('Vertex cover size', fontweight='bold')
ax3.set_title('(c) Algorithm Comparison: Cover Size', fontweight='bold')
ax3.legend(loc='upper left')
ax3.grid(True, alpha=0.3)

# Plot 4: Detailed view of best algorithm (matching-based)
ax4 = axes[1, 1]
R_vals = sorted(list(set([r['R'] for r in results_comparison if r['n'] == 300])))

ratios_by_R = []
for R in R_vals:
    ratios = [r['match_ratio'] for r in results_comparison
             if r['n'] == 300 and r['R'] == R]
    ratios_by_R.append(np.mean(ratios))

bars = ax4.bar(range(len(R_vals)), ratios_by_R,
              color=['#1f77b4', '#ff7f0e', '#2ca02c'], alpha=0.8)
ax4.axhline(y=2.0, color='r', linestyle='--', linewidth=2, alpha=0.7,
           label='Theoretical bound (2)')

for i, (bar, ratio) in enumerate(zip(bars, ratios_by_R)):
    height = bar.get_height()
    ax4.text(bar.get_x() + bar.get_width()/2., height + 0.02,
            f'{ratio:.3f}', ha='center', va='bottom', fontweight='bold')

ax4.set_xlabel('Communication radius (R)', fontweight='bold')
ax4.set_ylabel('Approximation ratio |C|/|M|', fontweight='bold')
ax4.set_title('(d) Matching-based Algorithm by Radius (n=300)', fontweight='bold')
ax4.set_xticks(range(len(R_vals)))
ax4.set_xticklabels(R_vals)
ax4.legend(loc='upper right')
ax4.grid(True, alpha=0.3, axis='y')
ax4.set_ylim(1.0, 2.1)

plt.suptitle('COMPARISON OF GREEDY ALGORITHMS FOR VERTEX COVER IN UDGs',
            fontsize=16, fontweight='bold', y=0.98)
plt.tight_layout()
plt.savefig('algorithm_comparison.png', dpi=300, bbox_inches='tight',
            facecolor='white', edgecolor='none')
plt.show()

print("‚úÖ Generated: algorithm_comparison.png")

# ============================================================================
# 4. VISUALIZATION 2: ALGORITHM DEMONSTRATION
# ============================================================================

print("\nüé® GENERATING ALGORITHM DEMONSTRATION...")

def visualize_algorithm_demo():
    np.random.seed(777)
    G, points = generate_udg(20, 0.3, seed=777)
    cover, matching = greedy_matching_based(G)

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

    # Plot 1: Source graph with matching
    ax1.set_title('(a) Maximal Matching Construction', fontweight='bold')

    # Draw all nodes
    for i, (x, y) in enumerate(points):
        ax1.plot(x, y, 'o', color='gray', alpha=0.6, markersize=12)
        ax1.text(x, y, str(i), ha='center', va='center', fontsize=8)

    # Draw edges in gray
    for u, v in G.edges():
        x1, y1 = points[u]
        x2, y2 = points[v]
        ax1.plot([x1, x2], [y1, y2], 'gray', alpha=0.3, linewidth=1)

    # Highlight matching edges
    for u, v in matching:
        x1, y1 = points[u]
        x2, y2 = points[v]
        ax1.plot([x1, x2], [y1, y2], 'red', linewidth=3, alpha=0.8)
        # Highlight matching vertices
        ax1.plot(x1, y1, 'o', color='red', markersize=15, alpha=0.7)
        ax1.plot(x2, y2, 'o', color='red', markersize=15, alpha=0.7)

    ax1.set_xlim(-0.05, 1.05)
    ax1.set_ylim(-0.05, 1.05)
    ax1.set_aspect('equal')
    ax1.grid(True, alpha=0.2)

    # Plot 2: Resulting Vertex Cover
    ax2.set_title('(b) Final Vertex Cover', fontweight='bold')

    # Draw all nodes
    for i, (x, y) in enumerate(points):
        if i in cover:
            # Cover nodes - red
            ax2.plot(x, y, 'o', color='red', markersize=15, alpha=0.8)
            ax2.text(x, y, str(i), ha='center', va='center',
                    fontsize=8, fontweight='bold', color='white')
        else:
            # Other nodes - gray
            ax2.plot(x, y, 'o', color='gray', alpha=0.6, markersize=12)
            ax2.text(x, y, str(i), ha='center', va='center', fontsize=8)

    # Draw all edges
    for u, v in G.edges():
        x1, y1 = points[u]
        x2, y2 = points[v]
        ax2.plot([x1, x2], [y1, y2], 'gray', alpha=0.3, linewidth=1)

    ax2.set_xlim(-0.05, 1.05)
    ax2.set_ylim(-0.05, 1.05)
    ax2.set_aspect('equal')
    ax2.grid(True, alpha=0.2)

    plt.suptitle('Step-by-Step Illustration of Matching-based Algorithm',
                fontsize=14, fontweight='bold', y=0.98)
    plt.tight_layout()
    plt.savefig('algorithm_demo.png', dpi=300, bbox_inches='tight')
    plt.show()

    print(f"‚úÖ Example: n=20, R=0.3")
    print(f"   Matching size: {len(matching)} edges")
    print(f"   Cover size: {len(cover)} vertices")
    print(f"   Ratio: {len(cover)/len(matching):.3f}")
    print("‚úÖ Generated: algorithm_demo.png")

visualize_algorithm_demo()

# ============================================================================
# 5. VISUALIZATION 3: SCALABILITY
# ============================================================================

print("\nüìà GENERATING SCALABILITY PLOT...")

# Collect detailed results for matching-based algorithm
np.random.seed(123)
detailed_results = []

for R in R_values:
    for n in n_values:
        covers = []
        times = []
        ratios = []
        matchings = []

        for trial in range(10):
            G, _ = generate_udg(n, R, seed=1000*trial + n)

            start = time.perf_counter()
            cover, matching = greedy_matching_based(G)
            elapsed = (time.perf_counter() - start) * 1000

            covers.append(len(cover))
            times.append(elapsed)
            matchings.append(len(matching))
            ratios.append(len(cover) / len(matching) if len(matching) > 0 else 0)

        avg_cover = np.mean(covers)
        avg_time = np.mean(times)
        avg_matching = np.mean(matchings)
        avg_ratio = np.mean(ratios)

        detailed_results.append({
            'n': n, 'R': R,
            'cover': avg_cover, 'time': avg_time,
            'matching': avg_matching, 'ratio': avg_ratio
        })

# Scalability plot
plt.figure(figsize=(10, 6))

for R in R_values:
    times_by_n = []
    n_vals_sorted = []

    for n in n_values:
        # Filter results for specific R and n
        relevant = [r for r in detailed_results if r['n'] == n and r['R'] == R]
        if relevant:
            times_by_n.append(relevant[0]['time'])
            n_vals_sorted.append(n)

    if times_by_n:
        plt.plot(n_vals_sorted, times_by_n, 'o-', linewidth=2,
                  markersize=8, label=f'R = {R}', alpha=0.8)

plt.xlabel('Number of vertices (n)', fontsize=12, fontweight='bold')
plt.ylabel('Running time (ms)', fontsize=12, fontweight='bold')
plt.title('Scalability of Matching-based Algorithm', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.savefig('scalability_plot.png', dpi=300, bbox_inches='tight')
plt.show()

print("‚úÖ Generated: scalability_plot.png")

# ============================================================================
# 6. VISUALIZATION 4: RADIUS EFFECT
# ============================================================================

print("\nüìê GENERATING RADIUS COMPARISON PLOT...")

plt.figure(figsize=(10, 6))

# Collect data
n_fixed = 300  # Fix graph size
R_labels = ['0.15', '0.20', '0.25']
degree_ratios = []
edge_ratios = []
match_ratios = []

for R in R_values:
    # Filter results
    relevant = [r for r in results_comparison if r['n'] == n_fixed and r['R'] == R]
    if relevant:
        degree_ratios.append(relevant[0]['degree_ratio'])
        edge_ratios.append(relevant[0]['edge_ratio'])
        match_ratios.append(relevant[0]['match_ratio'])

x = np.arange(len(R_labels))
width = 0.25

plt.bar(x - width, degree_ratios, width, label='Degree-based',
        color='#ff6b6b', alpha=0.8, edgecolor='black')
plt.bar(x, edge_ratios, width, label='Edge-based',
        color='#4ecdc4', alpha=0.8, edgecolor='black')
plt.bar(x + width, match_ratios, width, label='Matching-based',
        color='#45b7d1', alpha=0.8, edgecolor='black')

plt.axhline(y=2.0, color='red', linestyle='--', linewidth=2,
           alpha=0.7, label='Theoretical bound (2)')

plt.xlabel('Communication Radius (R)', fontsize=12, fontweight='bold')
plt.ylabel('Approximation Ratio |C|/|M|', fontsize=12, fontweight='bold')
plt.title(f'Algorithm Performance vs. Radius (n={n_fixed})',
         fontsize=14, fontweight='bold')
plt.xticks(x, R_labels)
plt.legend()
plt.grid(True, alpha=0.3, axis='y')
plt.tight_layout()
plt.savefig('radius_comparison.png', dpi=300, bbox_inches='tight')
plt.show()

print("‚úÖ Generated: radius_comparison.png")

# ============================================================================
# 7. TABLE AND FILE GENERATION
# ============================================================================

print("\nüìÑ GENERATING FINAL PUBLICATION TABLE...")

# Create LaTeX table for matching-based algorithm
latex_rows = []
for r in detailed_results:
    if r['n'] in [100, 200, 300, 400, 500]:
        latex_rows.append(
            f"{r['n']} & {r['R']} & {r['cover']:.1f} & {r['time']:.2f} & "
            f"{r['matching']:.1f} & {r['ratio']:.3f} \\\\"
        )

final_latex_table = r"""\begin{table}[ht]
\centering
\caption{Experimental results of the matching-based 2-approximation algorithm on random unit disk graphs.
Results are averaged over 10 random instances. The approximation ratio is computed as $|C|/|M|$ where $C$ is the vertex cover and $M$ is the maximal matching.}
\label{tab:final-results}
\begin{tabular}{cccccc}
\toprule
$n$ & $R$ & Cover Size & Time (ms) & Matching Size & Ratio \\
\midrule
""" + "\n".join(latex_rows) + r"""
\bottomrule
\end{tabular}
\end{table}"""

print("\n‚úÖ FINAL LaTeX TABLE FOR PUBLICATION:")
print("="*70)
print(final_latex_table)
print("="*70)

# Save LaTeX table
with open('final_results_table.tex', 'w', encoding='utf-8') as f:
    f.write(final_latex_table)

# Save raw data
with open('algorithm_comparison.csv', 'w', newline='', encoding='utf-8') as f:
    writer = csv.writer(f)
    writer.writerow(['n', 'R', 'algorithm', 'cover_size', 'time_ms', 'ratio'])

    for r in results_comparison:
        writer.writerow([r['n'], r['R'], 'degree', r['degree_cover'],
                        r['degree_time'], r['degree_ratio']])
        writer.writerow([r['n'], r['R'], 'edge', r['edge_cover'],
                        r['edge_time'], r['edge_ratio']])
        writer.writerow([r['n'], r['R'], 'matching', r['match_cover'],
                        r['match_time'], r['match_ratio']])

print("\n" + "="*70)
print("üéØ ALL DONE! FILES GENERATED:")
print("="*70)
print("1. üìä algorithm_comparison.png - Main comparison (4 subplots)")
print("2. üé® algorithm_demo.png - Algorithm demonstration")
print("3. üìà scalability_plot.png - Running time scalability")
print("4. üìê radius_comparison.png - Radius effect comparison")
print("5. üìã final_results_table.tex - LaTeX table for paper")
print("6. üìÑ algorithm_comparison.csv - Raw data")

from google.colab import files

# –°–∫–∞—á–∏–≤–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã
files_to_download = [
    'algorithm_comparison.png',
    'algorithm_demo.png',
    'scalability_plot.png',
    'radius_comparison.png',
    'final_results_table.tex',
    'algorithm_comparison.csv'
]

for file in files_to_download:
    try:
        files.download(file)
        print(f"‚úÖ Downloaded: {file}")
    except:
        print(f"‚ö†Ô∏è  Could not download: {file}")